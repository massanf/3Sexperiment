\documentclass{ltjsarticle}
\usepackage{luatexja}
%Packages -----------------------
\usepackage{listings}
\usepackage[euler]{textgreek}
\usepackage{enumitem}
\usepackage[margin=30mm]{geometry}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{float}
\usepackage{textcomp}
\usepackage{xparse}
%Circuit ------------------------
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage[siunitx, RPvoltages]{circuitikz}
%Circuit ------------------------
%Command ---–--------------------
\renewcommand{\figurename}{図}
\renewcommand{\baselinestretch}{1.1}
\lstset{
    numbers=left,
    basicstyle={\ttfamily},
    identifierstyle={\small},
    commentstyle={\smallitshape},
    keywordstyle={\small\bfseries},
    ndkeywordstyle={\small},
    stringstyle={\small\ttfamily},
    frame={tb},
    breaklines=true,
    columns=[l]{fullflexible},
    xrightmargin=0\zw,
    xleftmargin=3\zw,
    numberstyle={\scriptsize},
    stepnumber=1,
    %numbersep=1,
    lineskip=-0.5ex,
    keywordstyle=\color[HTML]{e10021},
    commentstyle=\color{gray},
    emph=CascadeObjectDetector,
    emphstyle=\color{blue}
}
%Command ------------------------
%Title   ------------------------
\title{実験レポート I1}
\author{東京大学工学部電気電子工学科 03210517\ 藤田 誠之 }
\date{ May 20, 2021}
%Title   ------------------------
\begin{document}
\maketitle
\section{実験目的}
実験の目的
\section{1日目: 間違い探し}
\subsection{00}
stdio.hがインクルードされていないため正常に動作しない。一行目に以下のコードを追加すれば想定通りに動く。
\begin{lstlisting}[caption=p00.c 変更部分,language=C]
#include <stdio.h>
\end{lstlisting}
\subsection{01}
sinやcosといった関数が使われているにも関わらず、math.hがインクルードされていないためエラーとなる。以下のコードを追加すれば設計通りに動作する。
\begin{lstlisting}[caption=p01.c 変更部分language=C]
#include <math.h>
\end{lstlisting}
\subsection{02}
printfはstdio.h、atofはstdlib.hがそれぞれインクルードされていないと使うことができない。冒頭に以下のコードを追加すれば設計通りに動作する。
\begin{lstlisting}[caption=p02.c 変更部分,language=C]
#include <stdio.h>
#include <stdlib.h>
\end{lstlisting}

\subsection{03}
pがmallocされていないため設計通りに動作しない。mk\_pointを以下のように変更すると動作するようになる。

\begin{lstlisting}[caption=p03.c 変更部分,language=C]
vect3 * mk_point(double x, double y, double z)
{
  vect3 * p;
  p = malloc(sizeof(vect3));　//変更部分
  p->x = x;
  p->y = y;
  p->z = z;
  return p;
}
\end{lstlisting}
\subsection{04}
vect3 p[1]となっていてもメモリの動的確保ができていないため正しく動作しない。mk\_point関数を以下のようにすれば正常に動作する。
\begin{lstlisting}[caption=p04.c 変更部分,language=C]
vect3 * mk_point(double x, double y, double z)
{
  vect3 * p;
  p = malloc(sizeof(vect3));　//追加部分
  p->x = x;
  p->y = y;
  p->z = z;
  return p;
}
\end{lstlisting}
\subsection{05}
ファイル名が間違っている。0が英字大文字のOとなっている。
\begin{lstlisting}[caption=p05.c 変更部分,language=C]
FILE * fp = fopen("p05.c","rb");
//FILE * fp = fopen("pO5.c","rb"); //間違い
\end{lstlisting}
\subsection{06}
同じく、ファイル名が間違っている。0が英字大文字のOとなっている。
\begin{lstlisting}[caption=p06.c 変更部分,language=C]
int fd = open("p06.c", O_RDONLY);
//int fd = open("pO6.c", O_RDONLY); //間違い
\end{lstlisting}
\subsection{07}
p07.cのプログラムは、文字をファイルから読み込み反対向きにしたものを出力する。以下のwhile文の中では、一行の大きさがわからないため、sが最初10バイトにセットされている。その後、文の終わりまで来ていなければsを10延長したい。そのため、一旦sの内容を保存するためにsよりも10長いtという新しい配列を用意し、それを新しくsとすることでより長い数列をmallocすることができた。
\begin{lstlisting}[caption=p07.c 変更部分,language=C]
while (1) {
  /* read as many bytes as s can store ((end - begin) bytes) */
  int r = fread(s + begin, 1, end - begin, fp);
  if (r < end - begin) {
    /* reached end of file */
    end = begin + r;
    break;
  }
  /* s is full and we have not reached end of file.
      we extend s by 10 bytes */
  begin = end;
  end += 10;
  char * t = (char *)malloc(end); /* new buffer */
  assert(t);
  bcopy(s, t, end);
  free(s);
  s=t; //追加部分
}
\end{lstlisting}
\subsection{08}
H\_expressionにおいて、「(」と「)」の新しい文字を読み込んだ際のみ文字の位置を参照するpの値が増えていない。文字を参照した後、pを1増やせば良い。つまり、H\_expressionを以下のように変更すれば良い。
\begin{lstlisting}[caption=p08.c 変更部分, language=C]
double H_expression() 
{
  /* if p points to the beginning of H expression
     in the definition 

     H ::= number | '(' E ')'

     return its value. otherwise signal syntax error
  */

  switch (*p) {
  case '0' ... '9': {
    return number();
  }
  case '(': {
    p++;  //追加部分1
    double x = E_expression();
    if (*p == ')') {
      p++; //追加部分2
      return x;
    } else {
      syntax_error();
    }
  }
  default:
    syntax_error();
  }
}
\end{lstlisting}

\section{2日目}
\subsection{準備課題2.1}
0バイト目に0, ... , 255バイト目に255が入るようなプログラムmk\_data.cは以下のようになる。
\begin{lstlisting}[caption=mk\_data.c,language=C]
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

int main (){
    int fd = open("my_data", O_WRONLY | O_CREAT | O_TRUNC , 0644);
    unsigned char data[256];
    for(int i = 0; i < 256; i++){
        data[i] = i;
    }
    write(fd,data,256);
    close(fd);
    return 0;
}
\end{lstlisting}
for構文を使い、my\_dataというファイルを作成し書き込む。もしすでに存在する場合は上書きする。
\subsection{準備課題2.2}
lsコマンドでファイルサイズを以下のように確認したところ、256バイトであることがわかった。
\begin{lstlisting}[caption=ファイルサイズの確認,language=bash]
% ls -l my_data
-rw-r--r--@ 1 masayukifujita  staff  256 May 27 00:37 my_data
\end{lstlisting}
また、catでこのファイルを開くと以下のように文字化けしている。

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=8cm]{figures/mojibake.png}
    \caption{ファイルの文字化け}
  \end{center}
\end{figure}

\subsection{準備課題2.3}
mk\_hitoshi.cを作る。以下のようになる。
\begin{lstlisting}[caption=hitoshi.c,language=C]
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

int main (){
    int fd = open("hitoshi", O_WRONLY | O_CREAT | O_TRUNC , 0644);
    unsigned char data[6];
    data[0] = 228;
    data[1] = 186;
    data[2] = 186;
    data[3] = 229;
    data[4] = 191;
    data[5] = 151;
    write(fd,data,6);
    close(fd);
    return 0;
}
\end{lstlisting}
この中身をcatコマンドで確認すると、以下のように表示される。
\begin{lstlisting}[caption=hitoshi]
人志
\end{lstlisting}
\subsection{準備課題2.4}
odコマンドでmy\_dataを表示すると以下のようになる。
\begin{lstlisting}[caption=od,language=bash]
% od -t u1 my_data
0000000     0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
0000020    16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
0000040    32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47
0000060    48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63
0000100    64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79
0000120    80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95
0000140    96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111
0000160   112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
0000200   128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143
0000220   144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
0000240   160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175
0000260   176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
0000300   192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
0000320   208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
0000340   224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239
0000360   240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255
0000400
\end{lstlisting}
実際にファイルの中身が表示されていることがわかる。
\subsection{準備課題2.5}
もう少しマシなmk\_data.c(コマンドライン引数でファイル名前を与えるプログラム)が以下である。
\begin{lstlisting}[caption=mk\_data2.c,language=C]
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sysexits.h>

int main (int argc, char ** argv){
    int fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC , 0644);
    if(fd == -1){
        perror("open");
        exit(1);
    }
    unsigned char data[256];
    for(int i = 0; i < 256; i++){
        data[i] = i;
    }
    write(fd,data,256);
    close(fd);
    return 0;
}
\end{lstlisting}
以下のように実行すると良い。
\begin{lstlisting}[caption=mk\_data2.c 実効,language=bash]
% gcc mk_data2.c -o mk_data2
% ./mk_data2 newfile
\end{lstlisting}

\subsection{準備課題2.6}
Listing15がそうである。存在しないディレクトリで実行すると以下のようになる。
\begin{lstlisting}[caption=mk\_data2 存在しないディレクトリで実効,language=bash]
% gcc mk_data2.c -o mk_data2
% ./mk_data2 foo/newfile
open: No such file or directory
\end{lstlisting}
このように、予期されるエラーが出た。

\subsection{準備課題2.7}
成功すると、書き込まれたバイト数が返される。エラーの場合、-1が返され、errnoにエラーの原因を示す値が設定される。

\section{本課題2.8}
データと、そのデータが何バイト目だったかを表示するプログラムread\_data.cは以下である。
\begin{lstlisting}[caption=read\_data.c,language=C]
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char** argv){
    int fd = open(argv[1],O_RDONLY);
    unsigned char data[1000];
    int i = 0;
    while(1){
        int n = read(fd,data,1000);
        if(n == -1){ perror("read"); exit(1); }
        if (n == 0) break;
        for(int j=0; j<n; j++){
            printf("%d %c\n",i,data[j]);
            i++;
        }
    }
}
\end{lstlisting}
実行すると、以下のようになる。
\begin{lstlisting}[caption=read\_data.c 実行,language=bash]
% gcc read_data.c -o read_data
% ./read_data my_data
0 0
1 1
2 2
...
254 254
255 255
\end{lstlisting}

\subsection{準備課題2.9}
音を取り込んだファイルをls -lで確認すると、以下のようになった。
\begin{lstlisting}[caption=recコマンド,language=bash]
% rec sound.wav

Input File     : 'default' (coreaudio)
Channels       : 1
Sample Rate    : 96000
Precision      : 32-bit
Sample Encoding: 32-bit Signed Integer PCM

In:0.00% 00:00:01.62 [00:00:00.00] Out:154k  [      |      ]        Clip:0    ^C
Aborted.
% ls -l sound.wav
-rw-r--r--  1 masayukifujita  staff  614480 May 27 01:34 sound.wav
\end{lstlisting}

\subsection{準備課題2.10}
再生する。先程録音したデータが再生された。
\begin{lstlisting}[caption=playコマンド,language=bash]
% play sound.wav
\end{lstlisting}

\subsection{準備課題2.11}
ファイル形式を変えて、おおよそ3秒間保存した。その結果をls -lコマンドでファイルサイズを確認した。
\begin{lstlisting}[caption=ファイル形式,language=C]
% ls -l a.wav
-rw-r--r--  1 masayukifujita  staff  1138768 May 27 01:40 a.wav
% ls -l a.raw
-rw-r--r--  1 masayukifujita  staff  1138688 May 27 01:40 a.raw
% ls -l a.dat
-rw-r--r--  1 masayukifujita  staff  10023154 May 27 01:40 a.dat
% ls -l a.ogg
-rw-r--r--  1 masayukifujita  staff  31952 May 27 01:40 a.ogg
\end{lstlisting}
.datが一番ファイルが大きく、.oggが一番小さいとわかる。

\subsection{準備課題2.12}
再生すると、録音したファイルが再生された。また、間違えた数値を入力すると、ピッチが高い音や低い音、壊れたような大音量などが聞こえた。


\section{参考文献}
『title』\url{<url>} 2021年n月m日アクセス
\end{document}